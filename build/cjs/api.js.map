{"version":3,"file":"api.js","sources":["../../src/api.ts"],"sourcesContent":["import { HostComponent } from \"./dsn\";\nimport { StackLineParser, StackLineParserFn, StackParser, createStackParser } from \"./types/stacktrace\";\nimport { urlEncode } from \"./utils/url\";\n\nconst RIBBAN_API_VERSION = '1';\n\nfunction getBaseAPIEndpoint(host: HostComponent): string {\n    const protocol = host.protocol ? `${host.protocol}:` : '';\n    const port = host.port ? `:${host.port}` : '';\n    return `${protocol}//${host.host}${port}${host.path ? `/${host.path}` : ''}/api/`;\n};\n\nfunction _encodedAuthentication(host: HostComponent): string {\n    return urlEncode({\n        ribban_key: host.publicKey,\n        ribban_version: RIBBAN_API_VERSION,\n    });\n};\n\nfunction _getIngestEndpoint(dsn: HostComponent): string {\n    return `${getBaseAPIEndpoint(dsn)}${dsn.projectId}/envelope`;\n}\n\nexport function getEnvelopeEndpointWithUrlEncodedAuth(dsn: HostComponent, tunnel?: string): string {\n    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuthentication(dsn)}`;\n}\n\nexport type GetModuleFn = (filename: string | undefined) => string | undefined;\n\n/**\n * Does this filename look like it's part of the app code?\n */\nexport function filenameIsInApp(filename: string, isNative: boolean = false): boolean {\n    const isInternal =\n      isNative ||\n      (filename &&\n        // It's not internal if it's an absolute linux path\n        !filename.startsWith('/') &&\n        // It's not internal if it's an absolute windows path\n        !filename.match(/^[A-Z]:/) &&\n        // It's not internal if the path is starting with a dot\n        !filename.startsWith('.') &&\n        // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n        !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//)); // Schema from: https://stackoverflow.com/a/3641782\n        \n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n        \n    return !isInternal && filename !== undefined && !filename.includes('node_modules/');\n}\n\nexport function node(getModule?: GetModuleFn): StackLineParserFn {\n    const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n    const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n  \n    // eslint-disable-next-line complexity\n    return (line: string) => {\n      const lineMatch = line.match(FULL_MATCH);\n  \n      if (lineMatch) {\n        let object: string | undefined;\n        let method: string | undefined;\n        let functionName: string | undefined;\n        let typeName: string | undefined;\n        let methodName: string | undefined;\n  \n        if (lineMatch[1]) {\n          functionName = lineMatch[1];\n  \n          let methodStart = functionName.lastIndexOf('.');\n          if (functionName[methodStart - 1] === '.') {\n            methodStart--;\n          }\n  \n          if (methodStart > 0) {\n            object = functionName.slice(0, methodStart);\n            method = functionName.slice(methodStart + 1);\n            const objectEnd = object.indexOf('.Module');\n            if (objectEnd > 0) {\n              functionName = functionName.slice(objectEnd + 1);\n              object = object.slice(0, objectEnd);\n            }\n          }\n          typeName = undefined;\n        }\n  \n        if (method) {\n          typeName = object;\n          methodName = method;\n        }\n  \n        if (method === '<anonymous>') {\n          methodName = undefined;\n          functionName = undefined;\n        }\n  \n        if (functionName === undefined) {\n          methodName = methodName || '?';\n          functionName = typeName ? `${typeName}.${methodName}` : methodName;\n        }\n  \n        let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n        const isNative = lineMatch[5] === 'native';\n  \n        // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\n        if (filename && filename.match(/\\/[A-Z]:/)) {\n          filename = filename.slice(1);\n        }\n  \n        if (!filename && lineMatch[5] && !isNative) {\n          filename = lineMatch[5];\n        }\n  \n        return {\n          filename,\n          module: getModule ? getModule(filename) : undefined,\n          function: functionName,\n          lineno: parseInt(lineMatch[3], 10) || undefined,\n          colno: parseInt(lineMatch[4], 10) || undefined,\n          in_app: filenameIsInApp(filename, isNative),\n        };\n      }\n  \n      if (line.match(FILENAME_MATCH)) {\n        return {\n          filename: line,\n        };\n      }\n  \n      return undefined;\n    };\n}\n  "],"names":["urlEncode"],"mappings":";;;;AAIA,MAAM,kBAAA,GAAqB,GAAG,CAAA;AAC9B;AACA,SAAS,kBAAkB,CAAC,IAAI,EAAyB;AACzD,IAAI,MAAM,WAAW,IAAI,CAAC,QAAS,GAAE,CAAC,EAAA,IAAA,CAAA,QAAA,CAAA,CAAA,CAAA,GAAA,EAAA,CAAA;AACA,IAAA,MAAA,IAAA,GAAA,IAAA,CAAA,IAAA,GAAA,CAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,EAAA,CAAA;AACA,IAAA,OAAA,CAAA,EAAA,QAAA,CAAA,EAAA,EAAA,IAAA,CAAA,IAAA,CAAA,EAAA,IAAA,CAAA,EAAA,IAAA,CAAA,IAAA,GAAA,CAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,EAAA,CAAA,KAAA,CAAA,CAAA;AACA,CACA;AACA,SAAA,sBAAA,CAAA,IAAA,EAAA;AACA,IAAA,OAAAA,aAAA,CAAA;AACA,QAAA,UAAA,EAAA,IAAA,CAAA,SAAA;AACA,QAAA,cAAA,EAAA,kBAAA;AACA,KAAA,CAAA,CAAA;AACA,CACA;AACA,SAAA,kBAAA,CAAA,GAAA,EAAA;AACA,IAAA,OAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,EAAA,GAAA,CAAA,SAAA,CAAA,SAAA,CAAA,CAAA;AACA,CAAA;AACA;AACA,SAAA,qCAAA,CAAA,GAAA,EAAA,MAAA,EAAA;AACA,IAAA,OAAA,MAAA,GAAA,MAAA,GAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA;AACA;;;;"}