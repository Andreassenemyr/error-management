{"version":3,"file":"api.js","sources":["../../src/api.ts"],"sourcesContent":["import { HostComponent } from \"./dsn\";\r\nimport { StackLineParser, StackLineParserFn, StackParser, createStackParser } from \"./types/stacktrace\";\r\nimport { urlEncode } from \"./utils/url\";\r\n\r\nconst RIBBAN_API_VERSION = '1';\r\n\r\nfunction getBaseAPIEndpoint(host: HostComponent): string {\r\n    const protocol = host.protocol ? `${host.protocol}:` : '';\r\n    const port = host.port ? `:${host.port}` : '';\r\n    return `${protocol}//${host.host}${port}${host.path ? `/${host.path}` : ''}/api/`;\r\n};\r\n\r\nfunction _encodedAuthentication(host: HostComponent): string {\r\n    return urlEncode({\r\n        ribban_key: host.publicKey,\r\n        ribban_version: RIBBAN_API_VERSION,\r\n    });\r\n};\r\n\r\nfunction _getIngestEndpoint(dsn: HostComponent): string {\r\n    return `${getBaseAPIEndpoint(dsn)}${dsn.projectId}/envelope/`;\r\n}\r\n\r\nexport function getEnvelopeEndpointWithUrlEncodedAuth(dsn: HostComponent, tunnel?: string): string {\r\n    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuthentication(dsn)}`;\r\n}\r\n\r\nexport type GetModuleFn = (filename: string | undefined) => string | undefined;\r\n\r\n/**\r\n * Does this filename look like it's part of the app code?\r\n */\r\nexport function filenameIsInApp(filename: string, isNative: boolean = false): boolean {\r\n    const isInternal =\r\n      isNative ||\r\n      (filename &&\r\n        // It's not internal if it's an absolute linux path\r\n        !filename.startsWith('/') &&\r\n        // It's not internal if it's an absolute windows path\r\n        !filename.match(/^[A-Z]:/) &&\r\n        // It's not internal if the path is starting with a dot\r\n        !filename.startsWith('.') &&\r\n        // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\r\n        !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//)); // Schema from: https://stackoverflow.com/a/3641782\r\n        \r\n    // in_app is all that's not an internal Node function or a module within node_modules\r\n    // note that isNative appears to return true even for node core libraries\r\n        \r\n    return !isInternal && filename !== undefined && !filename.includes('node_modules/');\r\n}\r\n\r\nexport function node(getModule?: GetModuleFn): StackLineParserFn {\r\n    const FILENAME_MATCH = /^\\s*[-]{4,}$/;\r\n    const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\r\n  \r\n    // eslint-disable-next-line complexity\r\n    return (line: string) => {\r\n      const lineMatch = line.match(FULL_MATCH);\r\n  \r\n      if (lineMatch) {\r\n        let object: string | undefined;\r\n        let method: string | undefined;\r\n        let functionName: string | undefined;\r\n        let typeName: string | undefined;\r\n        let methodName: string | undefined;\r\n  \r\n        if (lineMatch[1]) {\r\n          functionName = lineMatch[1];\r\n  \r\n          let methodStart = functionName.lastIndexOf('.');\r\n          if (functionName[methodStart - 1] === '.') {\r\n            methodStart--;\r\n          }\r\n  \r\n          if (methodStart > 0) {\r\n            object = functionName.slice(0, methodStart);\r\n            method = functionName.slice(methodStart + 1);\r\n            const objectEnd = object.indexOf('.Module');\r\n            if (objectEnd > 0) {\r\n              functionName = functionName.slice(objectEnd + 1);\r\n              object = object.slice(0, objectEnd);\r\n            }\r\n          }\r\n          typeName = undefined;\r\n        }\r\n  \r\n        if (method) {\r\n          typeName = object;\r\n          methodName = method;\r\n        }\r\n  \r\n        if (method === '<anonymous>') {\r\n          methodName = undefined;\r\n          functionName = undefined;\r\n        }\r\n  \r\n        if (functionName === undefined) {\r\n          methodName = methodName || '?';\r\n          functionName = typeName ? `${typeName}.${methodName}` : methodName;\r\n        }\r\n  \r\n        let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\r\n        const isNative = lineMatch[5] === 'native';\r\n  \r\n        // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\r\n        if (filename && filename.match(/\\/[A-Z]:/)) {\r\n          filename = filename.slice(1);\r\n        }\r\n  \r\n        if (!filename && lineMatch[5] && !isNative) {\r\n          filename = lineMatch[5];\r\n        }\r\n  \r\n        return {\r\n          filename,\r\n          module: getModule ? getModule(filename) : undefined,\r\n          function: functionName,\r\n          lineno: parseInt(lineMatch[3], 10) || undefined,\r\n          colno: parseInt(lineMatch[4], 10) || undefined,\r\n          in_app: filenameIsInApp(filename, isNative),\r\n        };\r\n      }\r\n  \r\n      if (line.match(FILENAME_MATCH)) {\r\n        return {\r\n          filename: line,\r\n        };\r\n      }\r\n  \r\n      return undefined;\r\n    };\r\n}\r\n  "],"names":["urlEncode"],"mappings":";;;;AAIA,MAAM,kBAAA,GAAqB,GAAG,CAAA;;AAE9B,SAAS,kBAAkB,CAAC,IAAI,EAAyB;AACzD,IAAI,MAAM,WAAW,IAAI,CAAC,QAAS,GAAE,CAAC,EAAA,IAAA,CAAA,QAAA,CAAA,CAAA,CAAA,GAAA,EAAA,CAAA;AACA,IAAA,MAAA,IAAA,GAAA,IAAA,CAAA,IAAA,GAAA,CAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,EAAA,CAAA;AACA,IAAA,OAAA,CAAA,EAAA,QAAA,CAAA,EAAA,EAAA,IAAA,CAAA,IAAA,CAAA,EAAA,IAAA,CAAA,EAAA,IAAA,CAAA,IAAA,GAAA,CAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,EAAA,CAAA,KAAA,CAAA,CAAA;AACA;AAEA,SAAA,sBAAA,CAAA,IAAA,EAAA;AACA,IAAA,OAAAA,aAAA,CAAA;AACA,QAAA,UAAA,EAAA,IAAA,CAAA,SAAA;AACA,QAAA,cAAA,EAAA,kBAAA;AACA,KAAA,CAAA,CAAA;AACA;AAEA,SAAA,kBAAA,CAAA,GAAA,EAAA;AACA,IAAA,OAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,EAAA,GAAA,CAAA,SAAA,CAAA,UAAA,CAAA,CAAA;AACA,CAAA;;AAEA,SAAA,qCAAA,CAAA,GAAA,EAAA,MAAA,EAAA;AACA,IAAA,OAAA,MAAA,GAAA,MAAA,GAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA;AACA;;;;"}