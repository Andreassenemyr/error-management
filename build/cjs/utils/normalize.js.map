{"version":3,"file":"normalize.js","sources":["../../../src/utils/normalize.ts"],"sourcesContent":["import { Primitive } from \"../scope\";\nimport { MemoFunc, memoBuilder } from \"./memo\";\nimport { convertToPlainObject } from \"./object\";\n\nexport function normalizeToSize<T>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    object: { [key: string]: any },\n    // Default Node.js REPL depth\n    depth: number = 3,\n    // 100kB, as 200kB is max payload size, so half sounds reasonable\n    maxSize: number = 100 * 1024,\n): T {\n    const normalized = normalize(object, depth);\n  \n    if (jsonSize(normalized) > maxSize) {\n      return normalizeToSize(object, depth - 1, maxSize);\n    }\n  \n    return normalized as T;\n}\n  \nexport function normalize(input: unknown, depth: number = 100, maxProperties: number = +Infinity): any {\n    try {\n      // since we're at the outermost level, we don't provide a key\n      return visit('', input, depth, maxProperties);\n    } catch (err) {\n      return { ERROR: `**non-serializable** (${err})` };\n    }\n}\nfunction visit(\n    key: string,\n    value: unknown,\n    depth: number = +Infinity,\n    maxProperties: number = +Infinity,\n    memo: MemoFunc = memoBuilder(),\n  ): Primitive | ObjOrArray<unknown> {\n    const [memoize, unmemoize] = memo;\n  \n    // Get the simple cases out of the way first\n    if (\n      value == null || // this matches null and undefined -> eqeq not eqeqeq\n      (['number', 'boolean', 'string'].includes(typeof value) && !Number.isNaN(value))\n    ) {\n      return value as Primitive;\n    }\n  \n    const stringified = stringifyValue(key, value);\n  \n    // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n    // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n    if (!stringified.startsWith('[object ')) {\n      return stringified;\n    }\n  \n    // From here on, we can assert that `value` is either an object or an array.\n  \n    // Do not normalize objects that we know have already been normalized. As a general rule, the\n    // \"__ribban_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n    // have already been normalized.\n    if ((value as ObjOrArray<unknown>)['__ribban_skip_normalization__']) {\n      return value as ObjOrArray<unknown>;\n    }\n  \n    // We can set `__ribban_override_normalization_depth__` on an object to ensure that from there\n    // We keep a certain amount of depth.\n    // This should be used sparingly, e.g. we use it for the redux integration to ensure we get a certain amount of state.\n    const remainingDepth =\n      typeof (value as ObjOrArray<unknown>)['__ribban_override_normalization_depth__'] === 'number'\n        ? ((value as ObjOrArray<unknown>)['__ribban_override_normalization_depth__'] as number)\n        : depth;\n  \n    // We're also done if we've reached the max depth\n    if (remainingDepth === 0) {\n      // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n      return stringified.replace('object ', '');\n    }\n  \n    // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n    if (memoize(value)) {\n      return '[Circular ~]';\n    }\n  \n    // If the value has a `toJSON` method, we call it to extract more information\n    const valueWithToJSON = value as unknown & { toJSON?: () => unknown };\n    if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n      try {\n        const jsonValue = valueWithToJSON.toJSON();\n        // We need to normalize the return value of `.toJSON()` in case it has circular references\n        return visit('', jsonValue, remainingDepth - 1, maxProperties, memo);\n      } catch (err) {\n        // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n      }\n    }\n  \n    // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n    // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n    // property/entry, and keep track of the number of items we add to it.\n    const normalized = (Array.isArray(value) ? [] : {}) as ObjOrArray<unknown>;\n    let numAdded = 0;\n  \n    // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n    // properties are non-enumerable and otherwise would get missed.\n    const visitable = convertToPlainObject(value as ObjOrArray<unknown>);\n  \n    for (const visitKey in visitable) {\n      // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n        continue;\n      }\n  \n      if (numAdded >= maxProperties) {\n        normalized[visitKey] = '[MaxProperties ~]';\n        break;\n      }\n  \n      // Recursively visit all the child nodes\n      const visitValue = visitable[visitKey];\n      normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);\n  \n      numAdded++;\n    }\n  \n    // Once we've visited all the branches, remove the parent from memo storage\n    unmemoize(value);\n  \n    // Return accumulated values\n    return normalized;\n}\n\ntype ObjOrArray<T> = { [key: string]: T };\n\nfunction stringifyValue(\n    key: unknown,\n    // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n    // our internal use, it'll do\n    value: Exclude<unknown, string | number | boolean | null>,\n  ): string {\n    try {\n      if (key === 'domain' && value && typeof value === 'object' && (value as { _events: unknown })._events) {\n        return '[Domain]';\n      }\n  \n      if (key === 'domainEmitter') {\n        return '[DomainEmitter]';\n      }\n  \n      // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n      // which won't throw if they are not present.\n  \n      if (typeof global !== 'undefined' && value === global) {\n        return '[Global]';\n      }\n  \n      // eslint-disable-next-line no-restricted-globals\n      if (typeof window !== 'undefined' && value === window) {\n        return '[Window]';\n      }\n  \n      // eslint-disable-next-line no-restricted-globals\n      if (typeof document !== 'undefined' && value === document) {\n        return '[Document]';\n      }\n\n  \n      if (typeof value === 'number' && value !== value) {\n        return '[NaN]';\n      }\n  \n      if (typeof value === 'function') {\n        return `[Function: ${getFunctionName(value)}]`;\n      }\n  \n      if (typeof value === 'symbol') {\n        return `[${String(value)}]`;\n      }\n  \n      // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n      if (typeof value === 'bigint') {\n        return `[BigInt: ${String(value)}]`;\n      }\n  \n      // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n      // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n      // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n      // we can make sure that only plain objects come out that way.\n      const objName = getConstructorName(value);\n  \n      // Handle HTML Elements\n      if (/^HTML(\\w*)Element$/.test(objName)) {\n        return `[HTMLElement: ${objName}]`;\n      }\n  \n      return `[object ${objName}]`;\n    } catch (err) {\n      return `**non-serializable** (${err})`;\n    }\n}\n\n/** Calculates bytes size of input object */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction jsonSize(value: any): number {\n    return utf8Length(JSON.stringify(value));\n}\n  \nfunction utf8Length(value: string): number {\n    // eslint-disable-next-line no-bitwise\n    return ~-encodeURI(value).split(/%..|./).length;\n}\n\ntype Prototype = { constructor: (...args: unknown[]) => unknown };\n\nfunction getConstructorName(value: unknown): string {\n    const prototype: Prototype | null = Object.getPrototypeOf(value);\n  \n    return prototype ? prototype.constructor.name : 'null prototype';\n}\n\nexport function getFunctionName(fn: unknown): string {\n    try {\n        if (!fn || typeof fn !== 'function') {\n            return defaultFunctionName;\n        }\n        return fn.name || defaultFunctionName;\n    } catch (e) {\n        // Just accessing custom props in some Selenium environments\n        // can cause a \"Permission denied\" exception (see raven-js#495).\n        return defaultFunctionName;\n    }\n}\n\nconst defaultFunctionName = '<anonymous>';"],"names":["memo","memoBuilder","convertToPlainObject"],"mappings":"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"}