{"version":3,"file":"client.js","sources":["../../src/client.ts"],"sourcesContent":["import { Extras, Scope } from \"./index\";\nimport { AsyncContextStack } from \"./async-context\";\nimport { BaseClient } from \"./baseclient\";\nimport { getMainCarrier, getRibbanCarrier } from \"./carrier\";\nimport { getClient, getCurrentScope, getIsolationScope } from \"./current-scopes\";\nimport { HostComponent } from \"./dsn\";\nimport { ClientOptions, Options } from \"./options\";\nimport { Session, SessionAggregates } from \"./session\";\nimport { SessionFlusher } from \"./sessionflusher\";\nimport { BaseTransportOptions, Transport, TransportMakeRequestResponse } from \"./transport\";\nimport { resolvedSyncPromise } from \"./transport/syncpromise\";\nimport { Envelope, Event, EventHint, SeverityLevel } from \"./types\";\nimport { Exception } from \"./types/exception\";\nimport { Mechanism } from \"./types/mechanism\";\nimport { StackFrame } from \"./types/stackframe\";\nimport { StackParser } from \"./types/stacktrace\";\nimport { logger } from \"./utils/logger\";\nimport { normalizeToSize } from \"./utils/normalize\";\nimport { extractExceptionKeysForMessage, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject } from \"./utils/object\";\nimport { ParameterizedString } from \"./utils/parameterize\";\nimport { isParameterizedString } from \"./transport/is\";\nimport { addExceptionMechanism, addExceptionTypeValue } from \"./utils/misc\";\n\n/**\n * User-Facing Ribban SDK Client.\n *\n * This interface contains all methods to interface with the SDK once it has\n * been installed. It allows to send events to Ribban, record breadcrumbs and\n * set a context included in every event. Since the SDK mutates its environment,\n * there will only be one instance during runtime.\n *\n */\nexport interface Client<O extends ClientOptions = ClientOptions> {\n    /**\n     * Captures an exception event and sends it to Ribban.\n     *\n     * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n     *\n     * @param exception An exception-like object.\n     * @param hint May contain additional information about the original exception.\n     * @param currentScope An optional scope containing event metadata.\n     * @returns The event id\n     */\n    captureException(exception: any, hint?: EventHint, currentScope?: Scope): string;\n  \n    /**\n     * Captures a message event and sends it to Ribban.\n     *\n     * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n     *\n     * @param message The message to send to Ribban.\n     * @param level Define the level of the message.\n     * @param hint May contain additional information about the original exception.\n     * @param currentScope An optional scope containing event metadata.\n     * @returns The event id\n     */\n    captureMessage(message: string, level?: SeverityLevel, hint?: EventHint, currentScope?: Scope): string;\n  \n    /**\n     * Captures a manually created event and sends it to Ribban.\n     *\n     * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n     *Ribban\n     * @param event The event to send to Ribban.\n     * @param hint May contain additional information about the original exception.\n     * @param currentScope An optional scope containing event metadata.\n     * @returns The event id\n     */\n    captureEvent(event: Event, hint?: EventHint, currentScope?: Scope): string;\n  \n    /**\n     * Captures a session\n     *\n     * @param session Session to be delivered\n     */\n    captureSession(session: Session): void;\n  \n    /** Returns the current Dsn. */\n    getDsn(): HostComponent | undefined;\n  \n    /** Returns the current options. */\n    getOptions(): O;\n  \n  \n    /**\n     * Returns the transport that is used by the client.\n     * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n     *\n     * @returns The transport.\n     */\n    getTransport(): Transport | undefined;\n  \n    /**\n     * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n     *\n     * @param timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n     *   the client to wait until all events are sent before disabling itself.\n     * @returns A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n     * it doesn't.\n     */\n    close(timeout?: number): PromiseLike<boolean>;\n  \n    /**\n     * Wait for all events to be sent or the timeout to expire, whichever comes first.\n     *\n     * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n     *   cause the client to wait until all events are sent before resolving the promise.\n     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n     * still events in the queue when the timeout is reached.\n     */\n    flush(timeout?: number): PromiseLike<boolean>;\n  \n    /**\n     * Initialize this client.\n     * Call this after the client was set on a scope.\n     */\n    init(): void;\n  \n    /** Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`. */\n    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;\n  \n    /** Submits the event to Ribban */\n    sendEvent(event: Event, hint?: EventHint): void;\n\n    \n    /** Submits the session to Ribban */\n    sendSession(session: Session | SessionAggregates): void;\n  \n    /** Sends an envelope to Ribban */\n    sendEnvelope(envelope: Envelope): PromiseLike<TransportMakeRequestResponse>;\n  \n    // HOOKS\n    /* eslint-disable @typescript-eslint/unified-signatures */\n  \n    /**\n     * Register a callback for transaction start and finish.\n     */\n    on(hook: 'beforeEnvelope', callback: (envelope: Envelope) => void): void;\n  \n    /**\n     * Register a callback for before sending an event.\n     * This is called right before an event is sent and should not be used to mutate the event.\n     * Receives an Event & EventHint as arguments.\n     */\n    on(hook: 'beforeSendEvent', callback: (event: Event, hint?: EventHint | undefined) => void): void;\n  \n    /**\n     * Register a callback for preprocessing an event,\n     * before it is passed to (global) event processors.\n     * Receives an Event & EventHint as arguments.\n     */\n    on(hook: 'preprocessEvent', callback: (event: Event, hint?: EventHint | undefined) => void): void;\n  \n    /**\n     * Register a callback for when an event has been sent.\n     */\n    on(hook: 'afterSendEvent', callback: (event: Event, sendResponse: TransportMakeRequestResponse) => void): void;\n\n    /**\n     * A hook that is called when the client is flushing\n     */\n    on(hook: 'flush', callback: () => void): void;\n  \n    /**\n     * A hook that is called when the client is closing\n     */\n    on(hook: 'close', callback: () => void): void;\n  \n    /*\n     * Fire a hook event for envelope creation and sending. Expects to be given an envelope as the\n     * second argument.\n     */\n    emit(hook: 'beforeEnvelope', envelope: Envelope): void;\n  \n    /**\n     * Fire a hook event before sending an event.\n     * This is called right before an event is sent and should not be used to mutate the event.\n     * Expects to be given an Event & EventHint as the second/third argument.\n     */\n    emit(hook: 'beforeSendEvent', event: Event, hint?: EventHint): void;\n  \n    /**\n     * Fire a hook event to process events before they are passed to (global) event processors.\n     * Expects to be given an Event & EventHint as the second/third argument.\n     */\n    emit(hook: 'preprocessEvent', event: Event, hint?: EventHint): void;\n  \n    /*\n     * Fire a hook event after sending an event. Expects to be given an Event as the\n     * second argument.\n     */\n    emit(hook: 'afterSendEvent', event: Event, sendResponse: TransportMakeRequestResponse): void;\n\n    /**\n     * Emit a hook event for client flush\n     */\n    emit(hook: 'flush'): void;\n  \n    /**\n     * Emit a hook event for client close\n     */\n    emit(hook: 'close'): void;\n  \n    /* eslint-enable @typescript-eslint/unified-signatures */\n}\n\nexport interface ServerRuntimeClientOptions extends ClientOptions<BaseTransportOptions> {\n    platform?: string;\n    runtime?: { name: string; version?: string };\n    serverName?: string;\n}\n  \n\n\n/**\n * Options added to the Browser SDK's init options that are specific for Replay.\n * Note: This type was moved to @sentry/types to avoid a circular dependency between Browser and Replay.\n */\nexport type BrowserClientReplayOptions = {\n    /**\n     * The sample rate for session-long replays.\n     * 1.0 will record all sessions and 0 will record none.\n     */\n    replaysSessionSampleRate?: number;\n  \n    /**\n     * The sample rate for sessions that has had an error occur.\n     * This is independent of `sessionSampleRate`.\n     * 1.0 will record all sessions and 0 will record none.\n     */\n    replaysOnErrorSampleRate?: number;\n};\n  \nexport type BrowserClientProfilingOptions = {\n    /**\n     * The sample rate for profiling\n     * 1.0 will profile all transactions and 0 will profile none.\n     */\n    profilesSampleRate?: number;\n};\n\nexport interface BrowserTransportOptions extends BaseTransportOptions {\n    /** Fetch API init parameters. Used by the FetchTransport */\n    fetchOptions?: RequestInit;\n    /** Custom headers for the transport. Used by the XHRTransport and FetchTransport */\n    headers?: { [key: string]: string };\n}\n\nexport type BrowserOptions = Options<BrowserTransportOptions> &\n  BrowserClientReplayOptions &\n  BrowserClientProfilingOptions;\n\nexport type BrowserClientOptions = ClientOptions<BrowserTransportOptions> &\n  BrowserClientReplayOptions &\n  BrowserClientProfilingOptions & {\n    /** If configured, this URL will be used as base URL for lazy loading integration. */\n    cdnBaseUrl?: string;\n  };\n\n\nexport class BrowserClient extends BaseClient<BrowserClientOptions> {\n    public constructor(options: BrowserClientOptions) {\n        super(options);\n    };\n\n    flush(timeout?: number | undefined): PromiseLike<boolean> {\n        return super.flush(timeout);\n    }\n\n    public eventFromException(exception: any, hint?: EventHint | undefined): PromiseLike<Event> {\n        console.log('Getting Event from Exception.', exception)\n\n        return eventFromException(this.options.stackParser, exception, hint, this.options.attachStacktrace);\n    }\n    \n    public eventFromMessage(message: string, level?: SeverityLevel, hint?: EventHint): PromiseLike<Event> {\n        return eventFromMessage(this.options.stackParser, message, level, hint, this.options.attachStacktrace);\n    };\n    \n    protected _prepareEvent(event: Event, hint: EventHint, currentScope?: Scope | undefined): PromiseLike<Event | null> {\n        event.platform = event.platform || 'javascript';\n        return super._prepareEvent(event, hint, currentScope);\n    };\n};\n\nexport function eventFromUnknownInput(\n    stackParser: StackParser,\n    exception: unknown,\n    syntheticException?: Error,\n    attachStacktrace?: boolean,\n    isUnhandledRejection?: boolean,\n): Event {\n    let event: Event;\n\n    console.log('Getting Event from unknown input.', exception)\n\n    if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n        const errorEvent = exception as ErrorEvent;\n        event = eventFromError(stackParser, errorEvent.error as Error);\n\n        console.log('Event from Error Event', event);\n    }\n\n    if (isDOMError(exception) || isDOMException(exception as DOMException)) {\n        const domException = exception as DOMException;\n\n        if ('stack' in (exception as Error)) {\n            event = eventFromError(stackParser, domException as Error);\n        } else {\n            const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n            const message = domException.message ? `${name}: ${domException.message}` : name;\n            event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n            addExceptionTypeValue(event, message);\n        }\n    }\n\n    if (isError(exception)) {\n        console.log('Event from Error', exception);\n\n        return eventFromError(stackParser, exception);\n    }\n\n    if (isPlainObject(exception) || isEvent(exception)) {\n        const objectException = exception as Record<string, unknown>;\n        event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n        addExceptionMechanism(event, {\n            synthetic: true,\n        });\n\n        return event;\n    };\n\n    console.log('Event from String', exception)\n\n    event = eventFromString(stackParser, `${exception}`, syntheticException, attachStacktrace);\n    addExceptionTypeValue(event, `${exception}`, undefined);\n    addExceptionMechanism(event, {\n        synthetic: true,\n    })\n\n    return event;\n}\n\nfunction eventFromString(\n    stackParser: StackParser,\n    message: ParameterizedString,\n    syntheticException?: Error,\n    attachStacktrace?: boolean,\n): Event {\n    const event: Event = {};\n  \n    if (attachStacktrace && syntheticException) {\n        const frames = parseStackFrames(stackParser, syntheticException);\n        if (frames.length) {\n            event.exception = {\n                values: [{ value: message, stacktrace: { frames } }],\n            };\n        }\n    }\n  \n    if (isParameterizedString(message)) {\n        const { __ribban_template_string__, __ribban_template_values__ } = message;\n        \n        event.logentry = {\n            message: __ribban_template_string__,\n            params: __ribban_template_values__,\n        };\n\n        return event;\n    }\n  \n    event.message = message;\n    return event;\n}\n\nexport function eventFromMessage(\n    stackParser: StackParser,\n    message: ParameterizedString,\n    level: SeverityLevel = 'info',\n    hint?: EventHint,\n    attachStacktrace?: boolean,\n): PromiseLike<Event> {\n    const syntheticException = (hint && hint.syntheticException) || undefined;\n\n    const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n    event.level = level;\n    \n    if (hint && hint.event_id) {\n        event.event_id = hint.event_id;\n    }\n\n    return resolvedSyncPromise(event);\n}\n  \n\nfunction eventFromError(stackParser: StackParser, ex: Error): Event {\n    return {\n        exception: {\n            values: [exceptionFromError(stackParser, ex)],\n        },\n    };\n}\n  \n\nexport function eventFromException(\n    stackParser: StackParser,\n    exception: unknown,\n    hint?: EventHint,\n    attachStacktrace?: boolean,\n): PromiseLike<Event> {\n    console.log('Getting Event from Exception.', exception)\n\n    const syntethicException = (hint && hint.syntheticException) || undefined;\n    const event = eventFromUnknownInput(stackParser, exception, syntethicException, attachStacktrace);\n\n    addExceptionMechanism(event);\n    event.level = 'error';\n\n    console.log(event);\n\n    if (hint && hint.event_id) {\n        event.event_id = hint.event_id;\n    };\n\n    return resolvedSyncPromise(event);\n}\n\n\nexport function setCurrentClient(client: Client): void {\n    getCurrentScope().setClient(client);\n    registerClientOnGlobalHub(client);\n}\n\nfunction registerClientOnGlobalHub(client: Client): void {\n    const ribbanGlobal = getRibbanCarrier(getMainCarrier()) as { hub?: AsyncContextStack };\n    if (ribbanGlobal.hub && typeof ribbanGlobal.hub.getStackTop === 'function') {\n        ribbanGlobal.hub.getStackTop().client = client;\n    }\n}\n  \n\nfunction getException(\n    client: Client,\n    mechanism: Mechanism,\n    exception: unknown,\n    hint?: EventHint,\n): [Error, Extras | undefined] {\n    if (isError(exception)) {\n        return [exception, undefined];\n    }\n  \n    // Mutate this!\n    mechanism.synthetic = true;\n  \n    if (isPlainObject(exception)) {\n        const normalizeDepth = client && client.getOptions().normalizeDepth;\n        const extras = { ['__serialized__']: normalizeToSize(exception as Record<string, unknown>, normalizeDepth) };\n        \n        const errorFromProp = getErrorPropertyFromObject(exception);\n        if (errorFromProp) {\n            return [errorFromProp, extras];\n        }\n      \n        const message = getMessageForObject(exception);\n        const ex = (hint && hint.syntheticException) || new Error(message);\n        ex.message = message;\n      \n        return [ex, extras];\n    }\n  \n    // This handles when someone does: `throw \"something awesome\";`\n    // We use synthesized Error here so we can extract a (rough) stack trace.\n    const ex = (hint && hint.syntheticException) || new Error(exception as string);\n    ex.message = `${exception}`;\n  \n    return [ex, undefined];\n}\n  \nfunction getMessageForObject(exception: Record<string, unknown>): string {\n    if ('name' in exception && typeof exception.name === 'string') {\n        let message = `'${exception.name}' captured as exception`;\n        \n        if ('message' in exception && typeof exception.message === 'string') {\n            message += ` with message '${exception.message}'`;\n        }\n      \n        return message;\n    } else if ('message' in exception && typeof exception.message === 'string') {\n        return exception.message;\n    }\n  \n    const keys = extractExceptionKeysForMessage(exception);\n  \n    // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n    // We still want to try to get a decent message for these cases\n    if (isErrorEvent(exception)) {\n        return `Event \\`ErrorEvent\\` captured as exception with message \\`${exception.message}\\``;\n    }\n  \n    const className = getObjectClassName(exception);\n  \n    return `${className && className !== 'Object' ? `'${className}'` : 'Object'} captured as exception with keys: ${keys}`;\n}\n\nfunction eventFromPlainObject(\n    stackParser: StackParser,\n    exception: Record<string, unknown>,\n    syntheticException?: Error,\n    isUnhandledRejection?: boolean,\n  ): Event {\n    const client = getClient();\n    const normalizeDepth = client && client.getOptions().normalizeDepth;\n  \n    // If we can, we extract an exception from the object properties\n    const errorFromProp = getErrorPropertyFromObject(exception);\n  \n    const extra = {\n      __serialized__: normalizeToSize(exception, normalizeDepth),\n    };\n  \n    if (errorFromProp) {\n        return {\n            exception: {\n                values: [exceptionFromError(stackParser, errorFromProp)],\n            },\n            extra,\n        };\n    }\n  \n    const event = {\n        exception: {\n            values: [\n                {\n                    type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n                    value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }),\n                } as Exception,\n            ],\n        },\n        extra,\n    } satisfies Event;\n  \n    if (syntheticException) {\n        const frames = parseStackFrames(stackParser, syntheticException);\n        if (frames.length) {\n            // event.exception.values[0] has been set above\n            event.exception.values[0].stacktrace = { frames };\n        }\n    }\n  \n    return event;\n}\n\nfunction getObjectClassName(obj: unknown): string | undefined | void {\n    try {\n        const prototype: unknown | null = Object.getPrototypeOf(obj);\n        return prototype ? prototype.constructor.name : undefined;\n    } catch (e) {\n        // ignore errors here\n    }\n}\n  \n\nexport function exceptionFromError(stackParser: StackParser, error: Error): Exception {\n    const exception: Exception = {\n        type: error.name || error.constructor.name,\n        value: error.message,\n    };\n\n    console.log(exception);\n  \n    const frames = parseStackFrames(stackParser, error);\n    if (frames.length) {\n        exception.stacktrace = { frames };\n    }\n  \n    return exception;\n}\n\nexport function parseStackFrames(stackParser: StackParser, error: Error): StackFrame[] {\n    return stackParser(error.stack || '', 1);\n}\n\nfunction getErrorPropertyFromObject(obj: Record<string, unknown>): Error | undefined {\n    for (const prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n            const value = obj[prop];\n            if (value instanceof Error) {\n                return value;\n            }\n        }\n    }\n  \n    return undefined;\n}\n  \nfunction getNonErrorObjectExceptionValue(\n    exception: Record<string, unknown>,\n    { isUnhandledRejection }: { isUnhandledRejection?: boolean },\n): string {\n    const keys = extractExceptionKeysForMessage(exception);\n    const captureType = isUnhandledRejection ? 'promise rejection' : 'exception';\n  \n    // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n    // We still want to try to get a decent message for these cases\n    if (isErrorEvent(exception)) {\n        return `Event \\`ErrorEvent\\` captured as ${captureType} with message \\`${exception.message}\\``;\n    }\n  \n    if (isEvent(exception)) {\n        const className = getObjectClassName(exception);\n        return `Event \\`${className}\\` (type=${exception.type}) captured as ${captureType}`;\n    }\n  \n    return `Object captured as ${captureType} with keys: ${keys}`;\n}"],"names":["BaseClient","isErrorEvent","isDOMError","isDOMException","addExceptionTypeValue","isError","isPlainObject","isEvent","addExceptionMechanism","isParameterizedString","resolvedSyncPromise","getCurrentScope","getRibbanCarrier","getMainCarrier","getClient","normalizeToSize","extractExceptionKeysForMessage"],"mappings":"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"}