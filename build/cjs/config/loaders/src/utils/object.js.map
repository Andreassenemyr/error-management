{"version":3,"file":"object.js","sources":["../../../../../../src/utils/object.ts"],"sourcesContent":["import { Primitive } from \"../scope\";\r\nimport { PolymorphicEvent } from \"../types/polymorhics\";\r\nimport { htmlTreeAsString } from \"./browser\";\r\nimport { logger } from \"./logger\";\r\n\r\nexport function dropUndefinedKeys<T>(inputValue: T): T {\r\n    const memoizationMap = new Map<unknown, unknown>();\r\n\r\n    return dropUndefinedKeysInner(inputValue, memoizationMap);\r\n};\r\n\r\nfunction dropUndefinedKeysInner<T>(inputValue: T, memoizationMap: Map<unknown, unknown>): T {\r\n    if (isRecord(inputValue)) {\r\n        const memoValue = memoizationMap.get(inputValue);\r\n        if (memoValue !== undefined) {\r\n            return memoValue as T;\r\n        };\r\n        \r\n        const returnValue: { [key: string]: unknown } = {};\r\n        memoizationMap.set(inputValue, returnValue);\r\n\r\n        for (const key of Object.keys(inputValue)) {\r\n            if (typeof inputValue[key] !== undefined) {\r\n                returnValue[key] = dropUndefinedKeysInner(inputValue[key], memoizationMap);\r\n            }\r\n        }\r\n\r\n        return returnValue as T;\r\n    }\r\n\r\n    if (Array.isArray(inputValue)) {\r\n        const memoValue = memoizationMap.get(inputValue);\r\n        if (memoValue !== undefined) {\r\n            return memoValue as T;\r\n        };\r\n\r\n        const returnValue: unknown[] = [];\r\n        memoizationMap.set(inputValue, returnValue);\r\n\r\n        inputValue.forEach((item: unknown) => {\r\n            returnValue.push(dropUndefinedKeysInner(item, memoizationMap)); \r\n        })\r\n\r\n        return returnValue as unknown as T;\r\n    };\r\n\r\n    return inputValue;\r\n};\r\n\r\nexport function isDOMException(wat: unknown): boolean {\r\n    return isBuiltin(wat, 'DOMException');\r\n}\r\n\r\nexport function isDOMError(wat: unknown): boolean {\r\n    return isBuiltin(wat, 'DOMError');\r\n}\r\n\r\nfunction isRecord(input: unknown): input is Record<string, unknown> {\r\n    if (!isPlainObject(input)) {\r\n        return false;\r\n    }\r\n  \r\n    try {\r\n        const name = (Object.getPrototypeOf(input) as { constructor: { name: string } }).constructor.name;\r\n        return !name || name === 'Object';\r\n    } catch {\r\n        return true;\r\n    }\r\n};\r\n\r\nconst objectToString = Object.prototype.toString;\r\n\r\nfunction isBuiltin(wat: unknown, className: string): boolean {\r\n    return objectToString.call(wat) === `[object ${className}]`;\r\n};\r\n  \r\n\r\nexport function isPlainObject(wat: unknown): wat is Record<string, unknown> {\r\n    return isBuiltin(wat, 'Object');\r\n};\r\n\r\nexport function addNonEnumerableProperty(obj: object, name: string, value: unknown): void {\r\n    try {\r\n        Object.defineProperty(obj, name, {\r\n            // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\r\n            value: value,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n    } catch (o_O) {\r\n        logger.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\r\n    }\r\n}\r\n\r\nexport function isPrimitive(wat: unknown): wat is Primitive {\r\n    return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\r\n}\r\n\r\nexport function isError(wat: unknown): wat is Error {\r\n    switch (objectToString.call(wat)) {\r\n        case '[object Error]':\r\n        case '[object Exception]':\r\n        case '[object DOMException]':\r\n            return true;\r\n        default:\r\n            return isInstanceOf(wat, Error);\r\n    }\r\n}\r\n\r\nexport function isInstanceOf(wat: any, base: any): boolean {\r\n    try {\r\n        return wat instanceof base;\r\n    } catch (_e) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function isRegExp(wat: unknown): wat is RegExp {\r\n    return isBuiltin(wat, 'RegExp');\r\n}\r\n  \r\n\r\nexport function extractExceptionKeysForMessage(exception: Record<string, unknown>, maxLength: number = 40): string {\r\n    const keys = Object.keys(convertToPlainObject(exception));\r\n    keys.sort();\r\n  \r\n    if (!keys.length) {\r\n        return '[object has no keys]';\r\n    }\r\n  \r\n    if (keys[0].length >= maxLength) {\r\n        return keys[0].substring(0, maxLength);\r\n    }\r\n  \r\n    for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\r\n        const serialized = keys.slice(0, includedKeys).join(', ');\r\n        if (serialized.length > maxLength) {\r\n            continue;\r\n        }\r\n        if (includedKeys === keys.length) {\r\n            return serialized;\r\n        }\r\n        return serialized.substring(0, maxLength);\r\n    }\r\n  \r\n    return '';\r\n}\r\n\r\nexport function convertToPlainObject<V>(value: V):\r\n    | {\r\n        [ownProps: string]: unknown;\r\n        type: string;\r\n        target: string;\r\n        currentTarget: string;\r\n        detail?: unknown;\r\n      }\r\n    | {\r\n        [ownProps: string]: unknown;\r\n        message: string;\r\n        name: string;\r\n        stack?: string;\r\n      }\r\n    | V {\r\n    if (isError(value)) {\r\n        return {\r\n            message: value.message,\r\n            name: value.name,\r\n            stack: value.stack,\r\n            ...getOwnProperties(value),\r\n        };\r\n    } else if (isEvent(value)) {\r\n        const newObj: {\r\n          [ownProps: string]: unknown;\r\n          type: string;\r\n          target: string;\r\n          currentTarget: string;\r\n          detail?: unknown;\r\n        } = {\r\n          type: value.type,\r\n          target: serializeEventTarget(value.target),\r\n          currentTarget: serializeEventTarget(value.currentTarget),\r\n          ...getOwnProperties(value),\r\n        };\r\n      \r\n        if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\r\n          newObj.detail = value.detail;\r\n        }\r\n      \r\n        return newObj;\r\n    } else {\r\n      return value;\r\n    }\r\n}\r\n\r\nfunction getOwnProperties(obj: unknown): { [key: string]: unknown } {\r\n    if (typeof obj === 'object' && obj !== null) {\r\n        const extractedProps: { [key: string]: unknown } = {};\r\n        for (const property in obj) {\r\n            if (Object.prototype.hasOwnProperty.call(obj, property)) {\r\n                extractedProps[property] = (obj as Record<string, unknown>)[property];\r\n            }\r\n        }\r\n        return extractedProps;\r\n    } else {\r\n        return {};\r\n    }\r\n}\r\n\r\nfunction serializeEventTarget(target: unknown): string {\r\n    try {\r\n        return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\r\n    } catch (_oO) {\r\n        return '<unknown>';\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether given value's type is an Element instance\r\n * {@link isElement}.\r\n *\r\n * @param wat A value to be checked.\r\n * @returns A boolean representing the result.\r\n */\r\nexport function isElement(wat: unknown): boolean {\r\n    return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\r\n}\r\n  \r\n\r\n\r\n/**\r\n * Checks whether given value's type is ErrorEvent\r\n * {@link isErrorEvent}.\r\n *\r\n * @param wat A value to be checked.\r\n * @returns A boolean representing the result.\r\n */\r\nexport function isErrorEvent(wat: unknown): boolean {\r\n    return isBuiltin(wat, 'ErrorEvent');\r\n}  \r\n\r\nexport function isString(wat: unknown): wat is string {\r\n    return isBuiltin(wat, 'String');\r\n}\r\n\r\nexport function isEvent(wat: unknown): wat is PolymorphicEvent {\r\n    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\r\n}\r\n\r\n  \r\n"],"names":[],"mappings":";;AAsEA,MAAM,iBAAiB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAA;;AAEhD,SAAS,SAAS,CAAC,GAAG,EAAW,SAAS,EAAmB;AAC7D,IAAI,OAAO,cAAc,CAAC,IAAI,CAAC,GAAG,CAAA,KAAM,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC,CAAA;AAC/D;AA2CO,SAAS,QAAQ,CAAC,GAAG,EAA0B;AACtD,IAAI,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAA;AACnC,CAAA;;AAyHO,SAAS,QAAQ,CAAC,GAAG,EAA0B;AACtD,IAAI,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAA;AACnC;;;;;"}