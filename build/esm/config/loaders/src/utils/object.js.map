{"version":3,"file":"object.js","sources":["../../../../../../src/utils/object.ts"],"sourcesContent":["import { Primitive } from \"../scope\";\nimport { PolymorphicEvent } from \"../types/polymorhics\";\nimport { htmlTreeAsString } from \"./browser\";\nimport { logger } from \"./logger\";\n\nexport function dropUndefinedKeys<T>(inputValue: T): T {\n    const memoizationMap = new Map<unknown, unknown>();\n\n    return dropUndefinedKeysInner(inputValue, memoizationMap);\n};\n\nfunction dropUndefinedKeysInner<T>(inputValue: T, memoizationMap: Map<unknown, unknown>): T {\n    if (isRecord(inputValue)) {\n        const memoValue = memoizationMap.get(inputValue);\n        if (memoValue !== undefined) {\n            return memoValue as T;\n        };\n        \n        const returnValue: { [key: string]: unknown } = {};\n        memoizationMap.set(inputValue, returnValue);\n\n        for (const key of Object.keys(inputValue)) {\n            if (typeof inputValue[key] !== undefined) {\n                returnValue[key] = dropUndefinedKeysInner(inputValue[key], memoizationMap);\n            }\n        }\n\n        return returnValue as T;\n    }\n\n    if (Array.isArray(inputValue)) {\n        const memoValue = memoizationMap.get(inputValue);\n        if (memoValue !== undefined) {\n            return memoValue as T;\n        };\n\n        const returnValue: unknown[] = [];\n        memoizationMap.set(inputValue, returnValue);\n\n        inputValue.forEach((item: unknown) => {\n            returnValue.push(dropUndefinedKeysInner(item, memoizationMap)); \n        })\n\n        return returnValue as unknown as T;\n    };\n\n    return inputValue;\n};\n\nexport function isDOMException(wat: unknown): boolean {\n    return isBuiltin(wat, 'DOMException');\n}\n\nexport function isDOMError(wat: unknown): boolean {\n    return isBuiltin(wat, 'DOMError');\n}\n\nfunction isRecord(input: unknown): input is Record<string, unknown> {\n    if (!isPlainObject(input)) {\n        return false;\n    }\n  \n    try {\n        const name = (Object.getPrototypeOf(input) as { constructor: { name: string } }).constructor.name;\n        return !name || name === 'Object';\n    } catch {\n        return true;\n    }\n};\n\nconst objectToString = Object.prototype.toString;\n\nfunction isBuiltin(wat: unknown, className: string): boolean {\n    return objectToString.call(wat) === `[object ${className}]`;\n};\n  \n\nexport function isPlainObject(wat: unknown): wat is Record<string, unknown> {\n    return isBuiltin(wat, 'Object');\n};\n\nexport function addNonEnumerableProperty(obj: object, name: string, value: unknown): void {\n    try {\n        Object.defineProperty(obj, name, {\n            // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n            value: value,\n            writable: true,\n            configurable: true,\n        });\n    } catch (o_O) {\n        logger.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n    }\n}\n\nexport function isPrimitive(wat: unknown): wat is Primitive {\n    return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\nexport function isError(wat: unknown): wat is Error {\n    switch (objectToString.call(wat)) {\n        case '[object Error]':\n        case '[object Exception]':\n        case '[object DOMException]':\n            return true;\n        default:\n            return isInstanceOf(wat, Error);\n    }\n}\n\nexport function isInstanceOf(wat: any, base: any): boolean {\n    try {\n        return wat instanceof base;\n    } catch (_e) {\n        return false;\n    }\n}\n\nexport function isRegExp(wat: unknown): wat is RegExp {\n    return isBuiltin(wat, 'RegExp');\n}\n  \n\nexport function extractExceptionKeysForMessage(exception: Record<string, unknown>, maxLength: number = 40): string {\n    const keys = Object.keys(convertToPlainObject(exception));\n    keys.sort();\n  \n    if (!keys.length) {\n        return '[object has no keys]';\n    }\n  \n    if (keys[0].length >= maxLength) {\n        return keys[0].substring(0, maxLength);\n    }\n  \n    for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n        const serialized = keys.slice(0, includedKeys).join(', ');\n        if (serialized.length > maxLength) {\n            continue;\n        }\n        if (includedKeys === keys.length) {\n            return serialized;\n        }\n        return serialized.substring(0, maxLength);\n    }\n  \n    return '';\n}\n\nexport function convertToPlainObject<V>(value: V):\n    | {\n        [ownProps: string]: unknown;\n        type: string;\n        target: string;\n        currentTarget: string;\n        detail?: unknown;\n      }\n    | {\n        [ownProps: string]: unknown;\n        message: string;\n        name: string;\n        stack?: string;\n      }\n    | V {\n    if (isError(value)) {\n        return {\n            message: value.message,\n            name: value.name,\n            stack: value.stack,\n            ...getOwnProperties(value),\n        };\n    } else if (isEvent(value)) {\n        const newObj: {\n          [ownProps: string]: unknown;\n          type: string;\n          target: string;\n          currentTarget: string;\n          detail?: unknown;\n        } = {\n          type: value.type,\n          target: serializeEventTarget(value.target),\n          currentTarget: serializeEventTarget(value.currentTarget),\n          ...getOwnProperties(value),\n        };\n      \n        if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n          newObj.detail = value.detail;\n        }\n      \n        return newObj;\n    } else {\n      return value;\n    }\n}\n\nfunction getOwnProperties(obj: unknown): { [key: string]: unknown } {\n    if (typeof obj === 'object' && obj !== null) {\n        const extractedProps: { [key: string]: unknown } = {};\n        for (const property in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, property)) {\n                extractedProps[property] = (obj as Record<string, unknown>)[property];\n            }\n        }\n        return extractedProps;\n    } else {\n        return {};\n    }\n}\n\nfunction serializeEventTarget(target: unknown): string {\n    try {\n        return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n    } catch (_oO) {\n        return '<unknown>';\n    }\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isElement(wat: unknown): boolean {\n    return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n  \n\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isErrorEvent(wat: unknown): boolean {\n    return isBuiltin(wat, 'ErrorEvent');\n}  \n\nexport function isString(wat: unknown): wat is string {\n    return isBuiltin(wat, 'String');\n}\n\nexport function isEvent(wat: unknown): wat is PolymorphicEvent {\n    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n  \n"],"names":[],"mappings":"AAsEA,MAAM,iBAAiB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAA;AAChD;AACA,SAAS,SAAS,CAAC,GAAG,EAAW,SAAS,EAAmB;AAC7D,IAAI,OAAO,cAAc,CAAC,IAAI,CAAC,GAAG,CAAA,KAAM,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC,CAAA;AAC/D,CA0CA;AACO,SAAS,QAAQ,CAAC,GAAG,EAA0B;AACtD,IAAI,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAA;AACnC,CAAA;;AAyHO,SAAS,QAAQ,CAAC,GAAG,EAA0B;AACtD,IAAI,OAAO,SAAS,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAA;AACnC;;;;"}