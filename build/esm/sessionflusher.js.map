{"version":3,"file":"sessionflusher.js","sources":["../../src/sessionflusher.ts"],"sourcesContent":["import { Client } from \"./client\";\r\nimport { getIsolationScope } from \"./current-scopes\";\r\nimport { AggregationCounts, RequestSessionStatus, SessionAggregates, SessionFlusherLike } from \"./session\";\r\nimport { dropUndefinedKeys } from \"./utils/object\";\r\n\r\ntype ReleaseHealthAttributes = {\r\n    environment?: string;\r\n};\r\n\r\n/**\r\n * @inheritdoc\r\n */\r\nexport class SessionFlusher implements SessionFlusherLike {\r\n    public readonly flushTimeout: number;\r\n    private _pendingAggregates: Record<number, AggregationCounts>;\r\n    private _sessionAttrs: ReleaseHealthAttributes;\r\n    // Cast to any so that it can use Node.js timeout\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private _intervalId: any;\r\n    private _isEnabled: boolean;\r\n    private _client: Client;\r\n\r\n    public constructor(client: Client, attrs: ReleaseHealthAttributes) {\r\n        this._client = client;\r\n        this.flushTimeout = 60;\r\n        this._pendingAggregates = {};\r\n        this._isEnabled = true;\r\n\r\n        // Call to setInterval, so that flush is called every 60 seconds.\r\n        this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n        if (this._intervalId.unref) {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n            this._intervalId.unref();\r\n        }\r\n        this._sessionAttrs = attrs;\r\n    }\r\n\r\n    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\r\n    public flush(): void {\r\n        const sessionAggregates = this.getSessionAggregates();\r\n        if (sessionAggregates.aggregates.length === 0) {\r\n            return;\r\n        }\r\n        this._pendingAggregates = {};\r\n        this._client.sendSession(sessionAggregates);\r\n    }\r\n\r\n    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\r\n    public getSessionAggregates(): SessionAggregates {\r\n        const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\r\n            return this._pendingAggregates[parseInt(key)];\r\n        });\r\n\r\n        const sessionAggregates: SessionAggregates = {\r\n            attrs: this._sessionAttrs,\r\n            aggregates,\r\n        };\r\n\r\n        return dropUndefinedKeys(sessionAggregates);\r\n    }\r\n\r\n    /** JSDoc */\r\n    public close(): void {\r\n        clearInterval(this._intervalId);\r\n        this._isEnabled = false;\r\n        this.flush();\r\n    }\r\n\r\n    /**\r\n     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\r\n     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\r\n     * `_incrementSessionStatusCount` along with the start date\r\n     */\r\n    public incrementSessionStatusCount(): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isolationScope = getIsolationScope();\r\n        const requestSession = isolationScope.getRequestSession();\r\n\r\n        if (requestSession && requestSession.status) {\r\n            this._incrementSessionStatusCount(requestSession.status, new Date());\r\n            // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\r\n            // case captureRequestSession is called more than once to prevent double count\r\n            isolationScope.setRequestSession(undefined);\r\n            /* eslint-enable @typescript-eslint/no-unsafe-member-access */\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\r\n     * the session received\r\n     */\r\n    private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\r\n        // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\r\n        const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\r\n        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || { started: '' };\r\n\r\n        // corresponds to aggregated sessions in one specific minute bucket\r\n        // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\r\n        const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\r\n        if (!aggregationCounts.started) {\r\n            aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\r\n        }\r\n\r\n        switch (status) {\r\n            case 'errored':\r\n                aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\r\n                return aggregationCounts.errored;\r\n            case 'ok':\r\n                aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\r\n                return aggregationCounts.exited;\r\n            default:\r\n                aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\r\n                return aggregationCounts.crashed;\r\n        }\r\n    }\r\n}"],"names":[],"mappings":"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"}