{"version":3,"file":"parse-proxy-response.js","sources":["../../../../src/node/proxy/parse-proxy-response.ts"],"sourcesContent":["/**\r\n * https://github.com/TooTallNate/proxy-agents/tree/b133295fd16f6475578b6b15bd9b4e33ecb0d0b7\r\n*/\r\n\r\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { IncomingHttpHeaders } from 'node:http';\r\nimport type { Readable } from 'node:stream';\r\nimport { logger } from '../../utils/logger';\r\n\r\nfunction debug(...args: unknown[]): void {\r\n    logger.log('[https-proxy-agent:parse-proxy-response]', ...args);\r\n}\r\n\r\nexport interface ConnectResponse {\r\n    statusCode: number;\r\n    statusText: string;\r\n    headers: IncomingHttpHeaders;\r\n}\r\n\r\nexport function parseProxyResponse(socket: Readable): Promise<{ connect: ConnectResponse; buffered: Buffer }> {\r\n    return new Promise((resolve, reject) => {\r\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\r\n        // the CONNECT response, so that if the response is anything other than an \"200\"\r\n        // response code, then we can re-play the \"data\" events on the socket once the\r\n        // HTTP parser is hooked up...\r\n        let buffersLength = 0;\r\n        const buffers: Buffer[] = [];\r\n\r\n        function read() {\r\n            const b = socket.read();\r\n            if (b) ondata(b);\r\n            else socket.once('readable', read);\r\n        }\r\n\r\n        function cleanup() {\r\n            socket.removeListener('end', onend);\r\n            socket.removeListener('error', onerror);\r\n            socket.removeListener('readable', read);\r\n        }\r\n\r\n        function onend() {\r\n            cleanup();\r\n            debug('onend');\r\n            reject(new Error('Proxy connection ended before receiving CONNECT response'));\r\n        }\r\n\r\n        function onerror(err: Error) {\r\n            cleanup();\r\n            debug('onerror %o', err);\r\n            reject(err);\r\n        }\r\n\r\n        function ondata(b: Buffer) {\r\n            buffers.push(b);\r\n            buffersLength += b.length;\r\n\r\n            const buffered = Buffer.concat(buffers, buffersLength);\r\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\r\n\r\n            if (endOfHeaders === -1) {\r\n                // keep buffering\r\n                debug('have not received end of HTTP headers yet...');\r\n                read();\r\n                return;\r\n            }\r\n\r\n            const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\\r\\n');\r\n            const firstLine = headerParts.shift();\r\n            if (!firstLine) {\r\n                socket.destroy();\r\n                return reject(new Error('No header received from proxy CONNECT response'));\r\n            }\r\n            const firstLineParts = firstLine.split(' ');\r\n            const statusCode = +firstLineParts[1];\r\n            const statusText = firstLineParts.slice(2).join(' ');\r\n            const headers: IncomingHttpHeaders = {};\r\n            for (const header of headerParts) {\r\n                if (!header) continue;\r\n                const firstColon = header.indexOf(':');\r\n                if (firstColon === -1) {\r\n                    socket.destroy();\r\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\r\n                }\r\n                const key = header.slice(0, firstColon).toLowerCase();\r\n                const value = header.slice(firstColon + 1).trimStart();\r\n                const current = headers[key];\r\n                if (typeof current === 'string') {\r\n                    headers[key] = [current, value];\r\n                } else if (Array.isArray(current)) {\r\n                    current.push(value);\r\n                } else {\r\n                    headers[key] = value;\r\n                }\r\n            }\r\n            debug('got proxy server response: %o %o', firstLine, headers);\r\n            cleanup();\r\n            resolve({\r\n                connect: {\r\n                    statusCode,\r\n                    statusText,\r\n                    headers,\r\n                },\r\n                buffered,\r\n            });\r\n        }\r\n\r\n        socket.on('error', onerror);\r\n        socket.on('end', onend);\r\n\r\n        read();\r\n    });\r\n}"],"names":[],"mappings":"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"}